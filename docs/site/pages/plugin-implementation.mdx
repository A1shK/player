---
title: Plugin Implementation
---
# Plugin Implementation

Plugins main capabilities are to tap into the player's lifecycle hooks and to add new functionality to the player. In this section we'll go over the steps to implement a plugin.

We'll use the [stage-revert-data](./plugins/stage-revert-data.md) plugin as example. After creating our plugin class, in the `apply` method we'll add the following code:

```typescript
export default class StageRevertDataPlugin implements PlayerPlugin {
  name = 'stage-revert-data-plugin';

  apply(player: Player) {
    let dataController: DataController;
    let stageData: String;
    let commitTransitions: String[];
    let commitShadowModel: Boolean = false;

    const GatedDataMiddleware = new ValidationMiddleware(
      () =>
        commitShadowModel
          ? undefined
          : {
              message: 'staging data',
              severity: 'error',
            },
      { shouldIncludeInvalid: () => true }
    );
```
We defined variables that will be used in the plugin:
- `dataController`: The data orchestrator of our Player instance
- `stageData`: State attribute that enables that comes from the view attribute content to enabling the staging of data
- `commitTransitions`: The list of view names which the shadow model should be committed if transitioned to. Comes from the view state attribute.
- `commitShadowModel`: Flag that enables committing shadow model into data model after the transition, if `stageData` is set to true and the next view name is included in `commitTransitions`.
- `GatedDataMiddleware` Data Middleware that will be used to intercept the data pipeline if `stageData` is set to true.

The next step is to tap into the necessary Player hooks. First we tap into the `viewController` which we can then intercept the `reolveView` hook. By defining our own property method `call` we can intercept the current view state and read the `stageData` and `commitTransitions` properties.

```javascript
    player.hooks.viewController.tap(this.name, (vc) => {
      vc.hooks.resolveView.intercept({
        call: (view, id, state) => {
          stageData = state?.attributes?.stageData;
          commitTransitions = state?.attributes?.commitTransitions;
        },
      });
    });
```
`Note`: notice how each time we tap into a hook, we use the `this.name` property as the name of the plugin. This is important to avoid conflicts with other plugins.

Next we tap into the `dataController`, so we can scope the data controller instance for future use. Then we tap into the `resolveDataStages` plugin in this data controller instance. If the `stage` property is set to true, we add our `GatedDataMiddleware` to the data pipeline. If not, we return the data pipeline as is.

```javascript
    player.hooks.dataController.tap(this.name, (dc: DataController) => {
      dataController = dc;

      dc.hooks.resolveDataStages.tap(this.name, (dataPipeline) => {
        return stageData
          ? [...dataPipeline, GatedDataMiddleware]
          : [...dataPipeline];
      });
    });
```
Finally, we tap into the `flowController` so we can intercept the `flow` hook. We then tap into the `transition` hook, which is called every time the player transitions from one view to another. If the `commitTransitions` includes the next view name, we set the `commitShadowModel` flag to true, and add the shadow model paths to the `GatedDataMiddleware`. If not, we clear the shadow model paths and set the `commitShadowModel` flag to false.

```javascript
    player.hooks.flowController.tap(this.name, (flowController) => {
      flowController.hooks.flow.tap(this.name, (flow) => {
        flow.hooks.transition.tap(this.name, (from, to) => {
          if (from) {
            if (commitTransitions.includes(to.name)) {
              commitShadowModel = true;
              player.logger.debug(
                'Shadow Model Data to be committed %s',
                GatedDataMiddleware.shadowModelPaths
              );
              dataController.set(GatedDataMiddleware.shadowModelPaths);
            }

            commitShadowModel = false;
            GatedDataMiddleware.shadowModelPaths.clear();
          }
        });
      });
    });
```

And this is how we implement a plugin that manages the staging of data based on the view state attributes.